# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/API/tnet.ipynb.

# %% auto 0
__all__ = ['are_edges_sorted', 'are_edges_directed', 'are_edges_connected', 'TempNet']

# %% ../nbs/API/tnet.ipynb 3
import numpy as np
from numba import prange
from .utils_ import ngpjit, ngjit

# %% ../nbs/API/tnet.ipynb 4
def _imagepair_from_bandwidth(nimages,bandwidth=None):
    if bandwidth is None: bandwidth = nimages
    assert nimages >= bandwidth
    ref, sec = np.triu_indices(nimages, 1)
    idx = np.where((sec-ref)<=bandwidth)
    return np.stack((ref[idx], sec[idx]),axis=-1).astype(np.int32)

# %% ../nbs/API/tnet.ipynb 5
@ngpjit
def are_edges_sorted(edges):
    num_edges = edges.shape[0]
    for i in prange(num_edges - 1):
        if edges[i, 0] > edges[i + 1, 0] or (edges[i, 0] == edges[i + 1, 0] and edges[i, 1] > edges[i + 1, 1]):
            return False
    return True

# %% ../nbs/API/tnet.ipynb 6
@ngpjit
def are_edges_directed(edges):
    '''directed = reference index smaller than secondary index'''
    num_edges = edges.shape[0]
    for i in prange(num_edges):
        if edges[i, 0] >= edges[i, 1]:
            return False
    return True

# %% ../nbs/API/tnet.ipynb 7
@ngjit
def are_edges_connected(edges):
    num_edges = edges.shape[0]

    current_ref = -1
    for i in range(num_edges):
        if edges[i,0] == current_ref:
            continue
        else:
            if edges[i,0] != edges[i,1]-1:
                return False
            current_ref = edges[i,0]
    return True

# %% ../nbs/API/tnet.ipynb 8
class TempNet(object):
    def __init__(self,image_pairs,check_if_valid=True):
        if check_if_valid:
            if not are_edges_sorted:
                raise ValueError('input image pairs are not sorted.')
            if not are_edges_directed:
                raise ValueError('input image pairs are not directed (reference index larger than or equal to secondary index).')
            if not are_edges_connected:
                raise ValueError('input image pairs are not connected.')
        self.image_pairs = image_pairs.astype(np.int32)

    @classmethod
    def from_bandwidth(cls, nimages, bandwidth=None):
        image_pairs = _imagepair_from_bandwidth(nimages,bandwidth)
        return cls(image_pairs,check_if_valid=False)

    def save(self,path:str, # zarr path
            ):
        '''Save the TempNet.'''
        tempnet_zarr = zarr.open(path,'w',shape=self.image_pairs.shape,dtype=self.image_pairs.dtype)
        tempnet_zarr[:] = self.image_pairs[:]

    @classmethod
    def load(cls, zarr_path:str, # zarr path
            ):
        '''classmethod to load the saved HilbertRtree.'''
        tempnet_zarr = zarr.open(path,'r')
        return cls(tempnet_zarr[:], check_if_valid=False)
